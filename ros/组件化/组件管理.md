ğŸ‘Œ è¿™ä¸ªç°è±¡è¯´æ˜ä¸¤ç‚¹ï¼š

1. **è¯·æ±‚ç¡®å®å‘å‡ºå»äº†**ï¼Œå› ä¸º `robot_control` å·²ç»æ”¶åˆ°äº† configure å’Œ activateï¼Œä¸”è¿›å…¥äº† `Activated`ã€‚
2. ä½†æ˜¯ **`async_send_request` çš„å›è°ƒå‡½æ•°å®Œå…¨æ²¡è§¦å‘**ï¼Œæ‰€ä»¥ä½ çœ‹ä¸åˆ° â€œTransition X SUCCESS/FAILEDâ€ã€‚

---

### ğŸ” ä¸ºä»€ä¹ˆå›è°ƒæ²¡è§¦å‘ï¼Ÿ

åœ¨ ROS 2 ç»„ä»¶é‡Œï¼Œæœ‰å‡ ä¸ªå¸¸è§å‘ï¼š

1. **client æ˜¯ä¸´æ—¶å˜é‡**
   ä½ åœ¨ `execute_lifecycle_transition` é‡Œè¿™æ ·å†™ï¼š

   ```cpp
   auto client = create_client<lifecycle_msgs::srv::ChangeState>(node_name + "/change_state");
   client->async_send_request(request, callback);
   ```

   `client` æ˜¯å±€éƒ¨å˜é‡ï¼Œå‡½æ•°ä¸€è¿”å›å°±é”€æ¯äº†ã€‚
   â†’ è¿™ä¼šå¯¼è‡´è¯·æ±‚å‘å‡ºå»äº†ï¼Œä½† response handler æ²¡æœ‰åœ°æ–¹æŒ‚è½½ï¼Œå›è°ƒæ°¸è¿œä¸ä¼šè§¦å‘ã€‚

2. **éœ€è¦æŒä¹…åŒ– client**
   å®˜æ–¹æ¨èæ˜¯æŠŠ client ä¿å­˜ä¸ºæˆå‘˜å˜é‡ï¼ˆæˆ–è‡³å°‘æ”¾åˆ°ä¸€ä¸ª `std::map` é‡Œï¼Œkey æ˜¯ node nameï¼‰ã€‚è¿™æ ·è¯·æ±‚å­˜åœ¨æ—¶ï¼Œclient ä¹Ÿè¿˜åœ¨ã€‚

---

### âœ… ä¿®æ”¹æ–¹æ³•

åœ¨ `LifecycleManager.hpp` é‡Œå¢åŠ ä¸€ä¸ªæˆå‘˜å˜é‡ï¼š

```cpp
std::map<std::string, rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedPtr> clients_;
```

ç„¶ååœ¨ `execute_lifecycle_transition` é‡Œæ”¹æˆï¼š

```cpp
void LifecycleManager::execute_lifecycle_transition(
  const std::string & node_name,
  uint8_t transition_id)
{
  if (clients_.find(node_name) == clients_.end()) {
    clients_[node_name] = this->create_client<lifecycle_msgs::srv::ChangeState>(
      node_name + "/change_state");
  }

  auto client = clients_[node_name];

  if (!client->wait_for_service(std::chrono::seconds(5))) {
    RCLCPP_ERROR(get_logger(), "Service unavailable for %s", node_name.c_str());
    return;
  }

  auto request = std::make_shared<lifecycle_msgs::srv::ChangeState::Request>();
  request->transition.id = transition_id;

  auto callback = [this, node_name, transition_id](rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedFuture future) {
    auto response = future.get();
    if (response->success) {
      RCLCPP_INFO(get_logger(), "Transition %d for %s SUCCESS",
                  transition_id, node_name.c_str());
    } else {
      RCLCPP_WARN(get_logger(), "Transition %d for %s FAILED",
                  transition_id, node_name.c_str());
    }
  };

  client->async_send_request(request, callback);
}
```

---

### ğŸ“Œ æ€»ç»“

* ä½ çš„è¯·æ±‚èƒ½è§¦å‘ç›®æ ‡èŠ‚ç‚¹çš„è¡Œä¸ºï¼Œè¯´æ˜ **è¯·æ±‚å‘å‡ºæˆåŠŸ**ã€‚
* ä½†æ˜¯å›è°ƒæ²¡æ‰§è¡Œï¼Œæ˜¯å› ä¸º **client åœ¨å‡½æ•°è¿”å›åè¢«é”€æ¯**ã€‚
* **è§£å†³æ–¹æ³•**ï¼šæŠŠ client ä¿å­˜æˆæˆå‘˜å˜é‡ï¼ˆmap / vector / å•ä¸ªéƒ½è¡Œï¼‰ï¼Œä¿è¯ç”Ÿå‘½å‘¨æœŸè¦†ç›–æ•´ä¸ªè¯·æ±‚å‘¨æœŸã€‚

---

è¦ä¸è¦æˆ‘å¸®ä½ æ•´ç†ä¸€ä»½å®Œæ•´çš„ `LifecycleManager.hpp / LifecycleManager.cpp`ï¼ˆç»„ä»¶ç‰ˆæœ¬ï¼‰ï¼ŒåŒ…å«ï¼š

* å‚æ•°è¯»å–
* å®šæ—¶å™¨è§¦å‘ configure + activate
* æŒä¹…åŒ– clients
  è¿™æ ·ä½ ç›´æ¥æ›¿æ¢æµ‹è¯•ï¼Ÿ
