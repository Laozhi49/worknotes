以下是实现**生命周期管理器节点**的完整解决方案，包含代码实现、启动文件配置和操作流程：

---

### 1. 创建生命周期管理器功能包
```bash
ros2 pkg create lifecycle_manager \
  --build-type ament_cmake \
  --dependencies rclcpp lifecycle_msgs
```

---

### 2. 实现管理器节点代码
创建 `lifecycle_manager/src/lifecycle_manager.cpp`：

```cpp
#include <memory>
#include <vector>
#include <string>
#include "rclcpp/rclcpp.hpp"
#include "lifecycle_msgs/srv/change_state.hpp"
#include "lifecycle_msgs/msg/transition.hpp"
#include "lifecycle_msgs/srv/get_state.hpp"

class LifecycleManager : public rclcpp::Node {
public:
    LifecycleManager() : Node("lifecycle_manager") {
        // 需要管理的节点列表（可通过参数配置）
        declare_parameter("managed_nodes", std::vector<std::string>{"/ultrasonic_controller", "/camera_controller"});
        managed_nodes_ = get_parameter("managed_nodes").as_string_array();

        // 创建定时器统一管理
        timer_ = create_wall_timer(
            std::chrono::seconds(3),  // 初始延迟
            std::bind(&LifecycleManager::manageNodes, this));
    }

private:
    void manageNodes() {
        timer_->cancel();  // 只执行一次
        
        // 分阶段管理所有节点
        configureAllNodes();
        
        // 延迟后激活
        activate_timer_ = create_wall_timer(
            std::chrono::seconds(5),
             { activateAllNodes(); });
    }

    void configureAllNodes() {
        for (const auto& node : managed_nodes_) {
            auto client = create_client<lifecycle_msgs::srv::ChangeState>(node + "/change_state");
            
            if (!client->wait_for_service(std::chrono::seconds(3))) {
                RCLCPP_WARN(get_logger(), "Service %s not available", client->get_service_name());
                continue;
            }

            auto request = std::make_shared<lifecycle_msgs::srv::ChangeState::Request>();
            request->transition.id = lifecycle_msgs::msg::Transition::TRANSITION_CONFIGURE;
            
            client->async_send_request(request,
                rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedFuture future {
                    if (future.get()->success) {
                        RCLCPP_INFO(get_logger(), "%s configured successfully", node.c_str());
                    } else {
                        RCLCPP_ERROR(get_logger(), "Failed to configure %s", node.c_str());
                    }
                });
        }
    }

    void activateAllNodes() {
        activate_timer_->cancel();
        
        for (const auto& node : managed_nodes_) {
            auto client = create_client<lifecycle_msgs::srv::ChangeState>(node + "/change_state");
            
            if (!client->wait_for_service(std::chrono::seconds(3))) {
                RCLCPP_WARN(get_logger(), "Service %s not available", client->get_service_name());
                continue;
            }

            auto request = std::make_shared<lifecycle_msgs::srv::ChangeState::Request>();
            request->transition.id = lifecycle_msgs::msg::Transition::TRANSITION_ACTIVATE;
            
            client->async_send_request(request,
                rclcpp::Client<lifecycle_msgs::srv::ChangeState>::SharedFuture future {
                    if (future.get()->success) {
                        RCLCPP_INFO(get_logger(), "%s activated successfully", node.c_str());
                        checkNodeState(node);  // 验证状态
                    } else {
                        RCLCPP_ERROR(get_logger(), "Failed to activate %s", node.c_str());
                    }
                });
        }
    }

    void checkNodeState(const std::string& node_name) {
        auto client = create_client<lifecycle_msgs::srv::GetState>(node_name + "/get_state");
        
        if (!client->wait_for_service(std::chrono::seconds(1))) return;
        
        auto request = std::make_shared<lifecycle_msgs::srv::GetState::Request>();
        client->async_send_request(request,
            rclcpp::Client<lifecycle_msgs::srv::GetState>::SharedFuture future {
                auto state = future.get()->current_state.id;
                RCLCPP_DEBUG(get_logger(), "%s current state: %d", node_name.c_str(), state);
            });
    }

    rclcpp::TimerBase::SharedPtr timer_;
    rclcpp::TimerBase::SharedPtr activate_timer_;
    std::vector<std::string> managed_nodes_;
};

int main(int argc, char** argv) {
    rclcpp::init(argc, argv);
    auto node = std::make_shared<LifecycleManager>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
```

---

### 3. 配置构建系统
修改 `lifecycle_manager/CMakeLists.txt`：

```cmake
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(lifecycle_msgs REQUIRED)

add_executable(lifecycle_manager src/lifecycle_manager.cpp)
ament_target_dependencies(lifecycle_manager
  rclcpp
  lifecycle_msgs
)

install(TARGETS lifecycle_manager
  DESTINATION lib/${PROJECT_NAME}
)

ament_package()
```

---

### 4. 创建启动文件
`lifecycle_manager/launch/manage_all.launch.py`：

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # 被管理的节点列表
    managed_nodes = [
        {"package": "ultrasonic_controller", "node": "ultrasonic_controller"},
        {"package": "camera_controller", "node": "camera_node"}
    ]
    
    # 启动所有被管理节点
    nodes_to_start = []
    for node in managed_nodes:
        nodes_to_start.append(
            Node(
                package=node["package"],
                executable=node["node"],
                name=node["node"],
                output="screen"
            )
        )
    
    # 启动管理器
    manager_node = Node(
        package="lifecycle_manager",
        executable="lifecycle_manager",
        name="lifecycle_manager",
        output="screen",
        parameters=[{
            "managed_nodes": ["/" + node["node"] for node in managed_nodes]
        }]
    )

    return LaunchDescription([
        *nodes_to_start,
        manager_node
    ])
```

---
### 修改CMake文件
```bash
# 安装启动文件（添加在 ament_package() 之前）
install(DIRECTORY
  launch
  DESTINATION share/${PROJECT_NAME}
)

```
----



### 5. 编译运行
```bash
# 在工作空间根目录
colcon build --symlink-install
source install/setup.bash

# 启动所有节点（包括管理器）
ros2 launch lifecycle_manager manage_all.launch.py
```

---

### 6. 高级功能扩展
#### 动态节点管理
通过服务接口动态添加/删除管理节点：

```cpp
// 在LifecycleManager类中添加
rclcpp::Service<lifecycle_manager_msgs::srv::AddNode>::SharedPtr add_node_service_;

void initServices() {
    add_node_service_ = create_service<lifecycle_manager_msgs::srv::AddNode>(
        "lifecycle_manager/add_node",
        [this](const std::shared_ptr<lifecycle_manager_msgs::srv::AddNode::Request> request,
               std::shared_ptr<lifecycle_manager_msgs::srv::AddNode::Response> response) {
            managed_nodes_.push_back(request->node_name);
            response->success = true;
        });
}
```

#### 状态监控看板
创建实时状态显示节点：
```python
ros2 run rqt_lifecycle rqt_lifecycle
```

---

### 关键注意事项
1. **启动顺序**：确保被管理节点先于管理器启动（上述启动文件已处理）
2. **超时处理**：所有服务调用都应设置超时（示例代码已包含）
3. **错误恢复**：可扩展管理器实现自动重试机制
4. **参数化配置**：通过ROS参数动态指定管理节点列表（示例已实现）

通过此方案，你可以获得：
- 集中化的生命周期控制
- 状态可视化能力
- 灵活的节点管理接口
- 完善的错误处理机制